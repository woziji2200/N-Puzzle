package stud.solver;

import core.problem.Problem;
import core.problem.State;
import core.solver.algorithm.heuristic.Predictor;
import core.solver.algorithm.searcher.AbstractSearcher;
import core.solver.queue.Frontier;
import core.solver.queue.Node;
import stud.queue.ListFrontier;

import java.util.*;

public class IdAStar extends AbstractSearcher {

    private final Predictor predictor;

    //裁剪阈值
    private int cutoff;
    //下一轮迭代的裁剪阈值
    private int newCutoff;
    //最大迭代深度
    private int maxIteratorDepth = 256;
    //统计扩展结点数
    private int expanded = 0;
    private int generated = 0;

    private final Stack<Node> openStack;
    //private final HashMap<Integer, Integer> closeStack;

    public IdAStar(Frontier frontier,Predictor predictor) {
        super(frontier);
        this.predictor = predictor;
        openStack = new Stack<Node>();
        //closeStack = new HashMap<Integer, Integer>();
    }

    @Override
    public Deque<Node> search(Problem problem) {
        if (!problem.solvable()){
            return null;
        }
        //获取根节点
        openStack.clear();
        //closeStack.clear();
        Node root = problem.root(predictor);
        cutoff = root.evaluation();

        while (cutoff < maxIteratorDepth) {
            openStack.push(root);
            newCutoff = cutoff;
            //当栈未空时继续，执行带裁剪值的深度优先搜索
            expanded = 0;
            while (!openStack.empty()) {
                expanded++;
                Node node = openStack.pop();
//                System.out.println("cost="+node.evaluation()+" pathCost="+node.getPathCost());
//                node.getState().draw();

                //更新裁剪值为未被探索节点中最小的评估值
                if (problem.goal(node.getState())) {
//                    System.out.println("cutoff="+cutoff+" expanded="+expanded);
                    return generatePath(node);
                }
                //当小于等于裁剪值时，继续向深处搜索
                for (Node child : problem.childNodes(node, predictor)) {
                    //剪枝，防止节点探索回到父节点
                    if (child.evaluation() <= cutoff) {
                        if (node.getParent() == null || !node.getParent().equals(child)) {

                            openStack.push(child);

                        }
                    } else {
                        //记录大于当前cutoff的最小值
                        newCutoff = (newCutoff > cutoff) ? (Math.min(child.evaluation(), newCutoff)) : child.evaluation();
                        //System.out.println("cutoff="+cutoff+" newcutoff="+newCutoff+" child.f="+child.evaluation());
                    }
                }
            }
            //更新裁剪值
            cutoff = newCutoff;
            //System.out.println("cutoff="+cutoff+" expanded="+expanded);
            //closeStack.clear();
            //System.out.println("cutoff: " + cutoff);
            //System.out.println("expanded node: " +  expanded);
        }
        return null;
    }

    @Override
    public int nodesExpanded() {
        return expanded;
    }

    @Override
    public int nodesGenerated() {
        return generated;
    }
}



///**
// * 迭代加深的A*算法，需要同学们自己编写完成
// */
//public class IdAStar extends AbstractSearcher {
//    Predictor predictor;
//    private Set<State> explored = new HashSet<>();
//    private Set<State> expanded = new HashSet<>();
//    // 返回的路径
//    Deque<Node> result = new ArrayDeque<>();
//    Problem local_problem;
//
//    public IdAStar(Frontier frontier, Predictor predictor) {
//        super(frontier); // Frontier跟深度优先搜索一样，使用堆栈作为Frontier
//        this.predictor = predictor;
//    }
//    /**
//     *
//     * @param node  当前状态
//     * @param parentNode 上一状态
//     * @param depth  最大探索深度
//     * @return
//     */
//    boolean depthFirstSearch(Node node, Node parentNode, int depth){
//        //剪枝
//        if (node.getPathCost() >= depth)
//            return false;
//        if (local_problem.goal(node.getState())) {
//            //如果抵达目标状态，回溯得到路径
//            result = generatePath(node);
//            return true;
//        }
//        //添加扩展结点
//        expanded.add(node.getState());
//        //生成子结点
//        List<Node> children = local_problem.childNodes(node, predictor);
//        //对每个子结点进行迭代
//        for (var child : children){
//            //添加生成结点
//            explored.add(child.getState());
//            //确保不会回到上一步
//            if (parentNode != null)
//                if(child.equals(parentNode))
//                    continue;
//            //小于最大深度则继续迭代
//            if (child.evaluation() < depth && depthFirstSearch(child, node, depth)) {
//                return true;
//            }
//        }
//        return false;
//    }
//    @Override
//    public Deque<Node> search(Problem problem) {
//        local_problem = problem;
//        //是否可解
//        if (!local_problem.solvable()) {
//            System.out.println("No Solution!");
//            return null;
//        }
//        // 起始节点root
//        Node root = local_problem.root(predictor);
//        //最大探索深度
//        int depth = root.getHeuristic();
//        while (!depthFirstSearch(root, null, depth)) {
//            depth++;
//        }
//        return result;
//    }
//    @Override
//    public int nodesExpanded() {
//        return expanded.size();
//    }
//    @Override
//    public int nodesGenerated() {
//        return explored.size();
//    }
//}